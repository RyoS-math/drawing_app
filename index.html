<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ä½œå›³ã‚¢ãƒ—ãƒª v20ï½œiPadå®Œå…¨å¯¾å¿œç‰ˆ</title>
<style>
  :root {
    --primary: #2563eb;
    --active-bg: #2563eb;
    --active-text: #ffffff;
    --panel-bg: #ffffff;
    --text: #334155;
    --border: #e2e8f0;
    --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
  }

  /* iPadå¯¾ç­–: ãƒã‚¦ãƒ³ã‚¹ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¨ã‚ºãƒ¼ãƒ ã‚’é˜²æ­¢ */
  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ */
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background-color: #f8fafc;
    color: var(--text);
    user-select: none;
    -webkit-user-select: none;
    touch-action: none; /* ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ã‚„ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—é˜²æ­¢ */
    overscroll-behavior: none; /* ãƒã‚¦ãƒ³ã‚¹é˜²æ­¢ */
  }

  #canvas-container {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
    touch-action: none; /* ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã®ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ç„¡åŠ¹åŒ– */
  }

  /* ãƒ‘ãƒãƒ«ã‚¹ã‚¿ã‚¤ãƒ« */
  .panel {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    background: var(--panel-bg);
    border: 1px solid var(--border);
    box-shadow: var(--shadow);
    border-radius: 8px;
    padding: 6px 12px;
    display: flex;
    align-items: center;
    gap: 8px;
    z-index: 10;
  }

  .top-bar { top: 20px; }
  .bottom-bar { bottom: 34px; }

  button {
    background: transparent;
    border: 1px solid transparent;
    border-radius: 4px;
    padding: 8px 12px; /* ã‚¿ãƒƒãƒã—ã‚„ã™ã„ã‚ˆã†å°‘ã—æ‹¡å¤§ */
    font-size: 14px;
    font-weight: 500;
    color: var(--text);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    transition: all 0.2s;
  }

  button:active { transform: scale(0.96); }
  button.active { background-color: var(--active-bg); color: var(--active-text); }

  .divider { width: 1px; height: 24px; background-color: var(--border); margin: 0 4px; }
  .icon { font-size: 1.1em; line-height: 1; }

  /* åŠå¾„ãƒœã‚¿ãƒ³ */
  .radius-btn { width: 40px; height: 40px; padding: 0; border-radius: 50%; border: 1px solid var(--border); }
  .radius-btn.active { border-color: var(--primary); background-color: var(--primary); color: #fff; }
  .radius-label { font-size: 12px; font-weight: bold; margin-right: 4px; color: #64748b; }

  /* ã‚¬ã‚¤ãƒ‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
  #msg {
    position: absolute; bottom: 90px; left: 50%; transform: translateX(-50%);
    background: rgba(15, 23, 42, 0.9); color: #fff; padding: 8px 20px;
    border-radius: 20px; font-size: 13px; font-weight: bold;
    pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 20; white-space: nowrap;
  }
  #msg.show { opacity: 1; }
</style>
</head>
<body>

<div id="canvas-container">
  <canvas id="cv"></canvas>
</div>

<div class="panel top-bar" id="modeGroup">
  <button data-mode="compass" class="active"><span class="icon">â—</span> ã‚³ãƒ³ãƒ‘ã‚¹</button>
  <button data-mode="ruler"><span class="icon">ğŸ“</span> å®šè¦</button>
  <button data-mode="point"><span class="icon">â—</span> ç‚¹</button>
  <button data-mode="erase"><span class="icon">âœ•</span> æ¶ˆå»</button>
  <div class="divider"></div>
  <button id="undoBtn">æˆ»ã‚‹</button>
  <button id="resetBtn">å…¨æ¶ˆå»</button>
</div>

<div class="panel bottom-bar" id="radiusControls">
  <span class="radius-label">åŠå¾„:</span>
  <button class="radius-btn" data-val="1">1</button>
  <button class="radius-btn" data-val="2">2</button>
  <button class="radius-btn active" data-val="3">3</button>
  <button class="radius-btn" data-val="4">4</button>
  <button class="radius-btn" data-val="5">5</button>
</div>

<div id="msg"></div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha: false });
  let DPR = 1;

  // --- çŠ¶æ…‹ç®¡ç† ---
  let mode = 'compass';
  let history = [];
  let objects = { points: [], lines: [], arcs: [] };

  // ã‚³ãƒ³ãƒ‘ã‚¹
  let center = null;
  let radiusSteps = [60, 100, 150, 220, 300];
  let radius = radiusSteps[2];
  let compassAngle = -Math.PI / 2;
  let isDraggingArm = false;

  // ãƒ„ãƒ¼ãƒ«
  let dragStart = null;
  let pointerPos = { x: 0, y: 0 };

  // --- åˆæœŸåŒ– ---
  function init() {
    const resize = () => {
      DPR = Math.max(1, window.devicePixelRatio || 1);
      const p = cv.parentElement;
      // è¦ªè¦ç´ ã®æ­£ç¢ºãªãƒ”ã‚¯ã‚»ãƒ«ã‚µã‚¤ã‚ºã‚’å–å¾—
      cv.width = p.clientWidth * DPR;
      cv.height = p.clientHeight * DPR;
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      draw();
    };
    window.addEventListener('resize', resize);
    resize();
    showMsg('ã‚³ãƒ³ãƒ‘ã‚¹: ä¸­å¿ƒã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦é…ç½®');
  }

  // --- åº§æ¨™å–å¾—ï¼ˆiPadå¯¾å¿œã®è‚ï¼‰ ---
  function getPos(e) {
    const rect = cv.getBoundingClientRect();
    // PointerEventã®clientXã¯ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆåŸºæº–ã€‚getBoundingClientRectã‚‚ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆåŸºæº–ã€‚
    // ãã®å·®åˆ†ãŒã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã®åº§æ¨™ã¨ãªã‚‹ã€‚
    return { 
      x: e.clientX - rect.left, 
      y: e.clientY - rect.top 
    };
  }

  function showMsg(text) {
    const el = document.getElementById('msg');
    el.innerText = text;
    el.classList.add('show');
    clearTimeout(el.timer);
    el.timer = setTimeout(() => el.classList.remove('show'), 2500);
  }

  function saveHistory() {
    if (history.length > 50) history.shift();
    history.push(JSON.stringify(objects));
  }

  // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ© ---
  
  // ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
  document.querySelectorAll('#modeGroup button[data-mode]').forEach(btn => {
    btn.addEventListener('click', (e) => {
      // ãƒœã‚¿ãƒ³é€£æ‰“ã«ã‚ˆã‚‹ã‚ºãƒ¼ãƒ ãªã©ã‚’é˜²æ­¢
      e.preventDefault();
      document.querySelectorAll('#modeGroup button[data-mode]').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      mode = btn.dataset.mode;
      dragStart = null; isDraggingArm = false;
      if (mode !== 'compass') center = null;
      if(mode === 'compass') showMsg('ä¸­å¿ƒã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦é…ç½®');
      else if(mode === 'ruler') showMsg('ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ç·šã‚’å¼•ã');
      draw();
    });
  });

  // åŠå¾„å¤‰æ›´
  document.querySelectorAll('#radiusControls button').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      document.querySelectorAll('#radiusControls button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      radius = radiusSteps[parseInt(btn.dataset.val) - 1];
      if (mode === 'compass' && center) compassAngle = -Math.PI / 2;
      draw();
    });
  });

  document.getElementById('undoBtn').onclick = (e) => { e.preventDefault(); if (history.length) { objects = JSON.parse(history.pop()); center = null; draw(); } };
  document.getElementById('resetBtn').onclick = (e) => { e.preventDefault(); saveHistory(); objects = { points: [], lines: [], arcs: [] }; center = null; draw(); };

  // --- ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ ---

  function handleDown(p, e) {
    // iPadã§ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œã‚’ç¢ºå®Ÿã«ã™ã‚‹ãŸã‚ã‚­ãƒ£ãƒ—ãƒãƒ£
    cv.setPointerCapture(e.pointerId);

    if (mode === 'point') {
      saveHistory(); objects.points.push(p);
    } 
    else if (mode === 'ruler') {
      dragStart = p;
    }
    else if (mode === 'compass') {
      if (!center) {
        center = p;
        compassAngle = -Math.PI / 2;
        showMsg("å…ˆç«¯ã®â—ã‚’ã¤ã‹ã‚“ã§å›ã™");
      } else {
        const tipX = center.x + radius * Math.cos(compassAngle);
        const tipY = center.y + radius * Math.sin(compassAngle);
        // æŒ‡ã§ã‚‚æ´ã¿ã‚„ã™ã„ã‚ˆã†ã«åˆ¤å®šåŠå¾„ã‚’å¤§ãã‚(60px)ã«è¨­å®š
        const dist = Math.hypot(p.x - tipX, p.y - tipY);

        if (dist < 60) { 
          isDraggingArm = true;
          saveHistory();
        } else {
          // å…ˆç«¯ä»¥å¤–ãªã‚‰ç§»å‹•
          center = p;
          compassAngle = -Math.PI / 2;
          showMsg("ã‚³ãƒ³ãƒ‘ã‚¹ã‚’ç§»å‹•");
        }
      }
    }
    else if (mode === 'erase') {
      tryErase(p);
    }
    draw();
  }

  function handleMove(p) {
    pointerPos = p;
    cv.style.cursor = 'crosshair';

    // ã‚³ãƒ³ãƒ‘ã‚¹æ“ä½œæ™‚ã®ã‚«ãƒ¼ã‚½ãƒ«ã¨ãƒ­ã‚¸ãƒƒã‚¯
    if (mode === 'compass' && center) {
      const tipX = center.x + radius * Math.cos(compassAngle);
      const tipY = center.y + radius * Math.sin(compassAngle);
      // ãƒ›ãƒãƒ¼åˆ¤å®šã‚‚å°‘ã—ç·©ã
      if (Math.hypot(p.x - tipX, p.y - tipY) < 60) cv.style.cursor = 'move';

      if (isDraggingArm) {
        const newAngle = Math.atan2(p.y - center.y, p.x - center.x);
        let diff = newAngle - compassAngle;
        // è§’åº¦è£œæ­£ï¼ˆ-PIã€œPIã¾ãŸãï¼‰
        while (diff <= -Math.PI) diff += 2 * Math.PI;
        while (diff > Math.PI) diff -= 2 * Math.PI;

        // æ€¥æ¿€ãªé£›ã³é˜²æ­¢
        if (Math.abs(diff) < 2.0) {
          objects.arcs.push({
            cx: center.x, cy: center.y, r: radius,
            s: compassAngle, e: newAngle, ccw: diff < 0
          });
          compassAngle = newAngle;
        }
      }
    }
    draw();
  }

  function handleUp() {
    if (mode === 'ruler' && dragStart) {
      saveHistory();
      objects.lines.push({ x1: dragStart.x, y1: dragStart.y, x2: pointerPos.x, y2: pointerPos.y });
      dragStart = null;
    }
    isDraggingArm = false;
    draw();
  }

  function tryErase(p) {
    const t = 20; // æ¶ˆã—ã‚´ãƒ åˆ¤å®šã‚‚æŒ‡å‘ã‘ã«å°‘ã—ç”˜ã
    const pi = objects.points.findIndex(pt => Math.hypot(pt.x - p.x, pt.y - p.y) < t);
    if (pi >= 0) { saveHistory(); objects.points.splice(pi, 1); return; }
    
    const li = objects.lines.findIndex(l => distPtSeg(p, l) < t);
    if (li >= 0) { saveHistory(); objects.lines.splice(li, 1); return; }
    
    const ai = objects.arcs.findIndex(a => Math.abs(Math.hypot(p.x - a.cx, p.y - a.cy) - a.r) < t);
    if (ai >= 0) {
      saveHistory();
      const target = objects.arcs[ai];
      objects.arcs = objects.arcs.filter(a =>
        !(Math.hypot(a.cx - target.cx, a.cy - target.cy) < 2 && Math.abs(a.r - target.r) < 2)
      );
    }
  }

  function distPtSeg(p, l) {
    const dx = l.x2 - l.x1, dy = l.y2 - l.y1;
    if (dx === 0 && dy === 0) return Math.hypot(p.x - l.x1, p.y - l.y1);
    let t = ((p.x - l.x1) * dx + (p.y - l.y1) * dy) / (dx * dx + dy * dy);
    t = Math.max(0, Math.min(1, t));
    return Math.hypot(p.x - (l.x1 + t * dx), p.y - (l.y1 + t * dy));
  }

  // --- æç”» ---
  function draw() {
    const w = cv.width / DPR;
    const h = cv.height / DPR;
    
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, w, h);
    drawGrid(w, h);

    // å††å¼§
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#000';
    ctx.beginPath();
    for (const a of objects.arcs) {
      ctx.moveTo(a.cx + a.r * Math.cos(a.s), a.cy + a.r * Math.sin(a.s));
      ctx.arc(a.cx, a.cy, a.r, a.s, a.e, a.ccw);
    }
    ctx.stroke();

    // ç›´ç·š
    ctx.strokeStyle = '#1e293b';
    ctx.beginPath();
    for (const l of objects.lines) {
      ctx.moveTo(l.x1, l.y1); ctx.lineTo(l.x2, l.y2);
    }
    ctx.stroke();

    // ç‚¹
    ctx.fillStyle = '#1e293b';
    for (const p of objects.points) {
      ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill();
    }

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
    if (mode === 'ruler' && dragStart) {
      ctx.strokeStyle = '#94a3b8'; ctx.setLineDash([5, 5]);
      ctx.beginPath(); ctx.moveTo(dragStart.x, dragStart.y); ctx.lineTo(pointerPos.x, pointerPos.y); ctx.stroke();
      ctx.setLineDash([]);
    }

    if (mode === 'compass' && center) {
      drawCompassTool();
    }
  }

  function drawGrid(w, h) {
    ctx.save();
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 1;
    ctx.beginPath();
    const step = 40;
    for (let x = 0; x <= w; x += step) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
    for (let y = 0; y <= h; y += step) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
    ctx.stroke();
    ctx.restore();
  }

  function drawCompassTool() {
    const cx = center.x, cy = center.y;
    const tipX = cx + radius * Math.cos(compassAngle);
    const tipY = cy + radius * Math.sin(compassAngle);

    // ã‚¬ã‚¤ãƒ‰å††
    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI * 2); ctx.stroke();
    ctx.setLineDash([]);

    // é‡
    ctx.fillStyle = '#ef4444';
    ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI * 2); ctx.fill();

    // è„š
    const grad = ctx.createLinearGradient(cx, cy, tipX, tipY);
    grad.addColorStop(0, '#cbd5e1'); grad.addColorStop(1, '#334155');
    ctx.strokeStyle = grad; ctx.lineWidth = 5; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(tipX, tipY); ctx.stroke();

    // ã¤ã¾ã¿
    ctx.fillStyle = isDraggingArm ? '#2563eb' : '#475569';
    ctx.beginPath(); ctx.arc(tipX, tipY, isDraggingArm ? 9 : 7, 0, Math.PI * 2); ctx.fill();
    
    // ãƒˆãƒƒãƒ—
    ctx.fillStyle = '#64748b';
    ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI * 2); ctx.fill();
  }

  // --- Pointer Events (ã‚¿ãƒƒãƒãƒ»ãƒã‚¦ã‚¹å…±é€š) ---
  cv.addEventListener('pointerdown', e => { e.preventDefault(); handleDown(getPos(e), e); });
  cv.addEventListener('pointermove', e => { e.preventDefault(); handleMove(getPos(e)); });
  cv.addEventListener('pointerup', e => { e.preventDefault(); handleUp(); });
  cv.addEventListener('pointercancel', e => { e.preventDefault(); handleUp(); });

  init();
})();
</script>
</body>
</html>